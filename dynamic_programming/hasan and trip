/*
Hasan and Trip
Send Feedback
Hasan has finally finished his final exams and he decided to go in a trip among cities in Syria.
There are N cities in Syria and they are numbered from 1 to N, each city has coordinates on plane, i-th city is in (Xi, Yi).
Hasan is in first city and he wants to visit some cities by his car in the trip but the final destination should be N-th city and the sequence of cities he will visit should be increasing in index (i.e. if he is in city i he can move to city j if and only if i < j ).
Visiting i-th city will increase Hasan's happiness by Fi units (including first and last cities), also Hasan doesn't like traveling too much, so his happiness will decrease by total distance traveled by him.
Help Hasan by choosing a sequence of cities to visit which maximizes his happiness.
Input format:
First line contain integer N.
Next N lines contains three integers each, i-th line contains coordinates of i-th city Xi, Yi and Fi.
Output format:
Output one number rounded to 6 digits after floating point, the maximum possible happiness Hasan can get. Note: If answer is 2 print 2.000000
Constraints:
1 <= N <= 3,000
0 <= Xi, Yi, Fi <= 100,000
Sample Input
3
0 0 1
3 1 1
6 0 9
Sample Output
4.675445
Explanation for the first test case:
According to the input, we have three coordinates: (0, 0), (3, 1) and (6, 0) and each of these coordinates have following happiness: 1, 1 and 9 respectively. 
Now, to get maximum happiness Hasan will start with (0, 0) and happiness of 1 units and he will travel from:
1. (0, 0) to (3, 1): This will increase its happiness by 1 and decrease it happiness by distance between these points, i.e. 3.162278 or square root of 10.
2. (3, 1) to (6, 0): This will increase its happiness by 9 and decrease it happiness by distance between these points, i.e. 3.162278 or square root of 10.

Hence, Hasan's happiness will be: 1 + 1 - 3.162278 + 9 - 3.162278 = 4.675445.
*/
import java.util.*;

public class Main {

	
	public static void main(String[] args) {
		// Write your code here
		Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        
        Pair[] arr = new Pair[n+1];
        for(int i=1;i<=n;i++){
            arr[i]= new Pair(sc.nextInt(), sc.nextInt(), sc.nextInt());         
        }
        
        double[] dp = new double[n+1];
        Arrays.fill(dp, Integer.MIN_VALUE);
        double ans = fun(dp, n, arr);
        System.out.printf("%.6f", ans);
    }
    
    public static double fun(double[] dp, int n, Pair[] arr) {	
        dp[1]=arr[1].f;
        dp[2]=arr[2].f + dp[1] - distance(arr[1], arr[2]);
        for(int i=3; i<=n; i++) {
            for(int j=i-1;j>=1;j--){
                double temp = arr[i].f + dp[j] - distance(arr[i], arr[j]);
                if(temp>dp[i]){
                    dp[i]=temp;
                }
            }
        }
        return dp[n];
    }
    
    public static double distance(Pair p1, Pair p2) {
        return (double)Math.sqrt( Math.pow((p2.x-p1.x),2) + Math.pow((p2.y-p1.y),2) );
    }
}

class Pair {
    
    int x;
    int y;
    int f;
    
    Pair(int x, int y, int f) {
        this.x=x;
        this.y=y;
        this.f=f;
    }
}
